package org.jetbrains.plugins.scala.lang.typeConformance
package generated

class TypeConformanceExistentialTest extends TypeConformanceTestBase {
  //This class was generated by build script, please don't change this
  override def folderPath: String = super.folderPath + "existential/"

  //todo:
  /*def testBadLowerBound() {doTest()}*/

  //todo:
  /*def testBadLowerBound2() {doTest()}*/

  //todo:
  /*def testBadLowerBoundPrimitive() {doTest()}*/

  def testBadLowerUpper(): Unit = {doTest()}

  def testBadToExistential(): Unit = {doTest()}

  def testInnerPlaceHolder(): Unit = {doTest()}

  def testInnerPlaceholderBack(): Unit = {doTest()}

  def testLowerBound(): Unit = {doTest()}

  def testLowerBound2(): Unit = {doTest()}

  def testLowerBoundAbstract(): Unit = {doTest()}

  //todo:
  /*def testLowerBoundAbstract2() {doTest()}*/

  def testLowerBoundPrimitive(): Unit = {doTest()}

  def testLowerBoundsPrimitiveCovariant(): Unit = {doTest()}

  def testLowerUpperBouns(): Unit = {doTest()}

  def testSCL2977(): Unit = {doTest()}

  def testSCL2977B(): Unit = {doTest()}

  def testToExistential(): Unit = {doTest()}

  def testToExistentialSimple(): Unit = {doTest()}

  //SCL-10295
  def testExistentialWithAliasedDesignator(): Unit = {doTest()}

  def testSCL12127ConformanceFreeze(): Unit = {
    doTest(
      """
        |abstract class Quantity[A <: Quantity[A]] extends Serializable with Ordered[A] {
        |  self: A â‡’
        |}
        |
        |trait Dimension[A <: Quantity[A]]
        |
        |type RQuantity = T forSome {type T <: Quantity[T]}
        |type RDimension = Dimension[_ <: RQuantity]
        |
        |val rq: RQuantity = ???
        |val x: Function[_, _] = rq
        |//false
        |""".stripMargin
    )
  }

  def testSCL13326(): Unit = {doTest()}

  def testSCL13326_1(): Unit = {doTest()}

  def testSCL7602(): Unit = {
    doApplicationConformanceTest(
      s"""
         |class A[P[T]]{
         |  def use[T](p: P[T]) = ()
         |  def get: P[_] = ???
         |  use$caretMarker(get) //error
         |}
      """.stripMargin)
  }

  def testEquivalentRecursive(): Unit = {
    doTest(checkEquivalence = true, fileText =
      """
        |trait Foo[T]
        |
        |val x: Foo[T] forSome {type T <: Foo[T]} = null
        |
        |val y: Foo[T1] forSome {type T1 <: Foo[T1]} = x
        |//true
      """.stripMargin)
  }

  def testEquivalentRecursive2(): Unit = {
    doTest(checkEquivalence = true, fileText =
      """
        |trait Bar[X, Y]
        |
        |val b1: Bar[X1, Y1] forSome {type X1 <: Bar[X1, Y1]; type Y1 <: Bar[X1, Y1]} = null
        |
        |val b2: Bar[X2, Y2] forSome {type X2 <: Bar[X2, Y2]; type Y2 <: Bar[X2, Y2]} = b1
        |//true
      """.stripMargin
    )
  }

  def testEquivalentDifferentOrder(): Unit = {
    doTest(checkEquivalence = true, fileText =
      """
        |trait Bar[X, Y]
        |
        |val b1: Bar[X1, Y1] forSome {type X1 <: Bar[X1, Y1]; type Y1 <: Bar[X1, Y1]} = null
        |
        |val b2: Bar[X2, Y2] forSome {type Y2 <: Bar[X2, Y2]; type X2 <: Bar[X2, Y2]} = b1
        |//true
      """.stripMargin
    )
  }

  def testSCL9402(): Unit = {
    val text =
      """import scala.language.existentials
        |
        |class Network {
        |  class Member(val name: String)
        |
        |  def join(name: String): Member = ???
        |}
        |
        |type NetworkMember = n.Member forSome {val n: Network}
        |
        |val chatter = new Network
        |
        |val fred: chatter.Member = chatter.join("Fred")
        |
        |val x: NetworkMember = fred
        |//True""".stripMargin
    doTest(text)
  }

}